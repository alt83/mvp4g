#summary Draft for 1.1.0 version

=Event Bus=

The main goal of Mvp4g is to allow you to easily set an event bus and events without creating classes and interfaces for each event.

An event is defined by:
 * its name (or type)
 * the type of object that can be associated with it.

All you have to do to create an event bus and events is to create an EventBus interface and define one method for each event. An implementation of this interface will be automaticaly generated by the framework and will be injected to each presenter. A singleton pattern is used to create the event bus.

Thus Mvp4g provides an easy and strongly-type way to define an event.

==Creating an event bus==

To create an event bus, you need to:
 * create an interface that extends com.mvp4g.client.event.EventBus or com.mvp4g.client.event.EventBusWithLookup (see for the difference)
 * annotate it with @Events

Annotation @Events has the following attributes:
 * startView (mandatory) and startViewName (optional), see ...
 * historyOnStart (optional, by default false), use only in case of history management, see ...
 * module (optional, by default Mvp4gModule), use only in case of multi-module, see ...
 * debug (optional, by default false), see ...

{{{
@Events(startView = MainView.class)
public interface MainEventBus extends EventBus { ... }
}}}

==Creating an event==

To create an event, you need to:
 * create a method in your event bus interface. This method shouldn't return anything and  have up to one parameter. If the method has no parameter, it means that no object can be associated with the event.
 * annotate it with @Event.

{{{
@Events(startView = MainView.class, historyOnStart = true)
public interface MainEventBus extends EventBusWithLookup {

	@Event(...)
	public void goToCompany();

	@Event(...)
	public void changeBody(Widget newBody);

	...
}
}}}

Annotation @Event has the following at attributes:
 * handlers and handlerNames (see ...)
 * calledMethod (see ...)
 * historyConverter and historyConverterName, use only in case of history management(see ...)
 * modulesToLoad and forwardToParent (see ...)

==Adding an handler to an event==

Only presenters can be an handler of an event. To add an handler to an event you just have to add its class to the attribute handlers of the @Event annotation that annotates the method of your event in your event bus interface.

{{{
@Event(handlers=CompanyListPresenter.class)
public void companyDeleted(CompanyBean newBean);

@Event(handlers={CompanyListPresenter.class, CompanyDisplayPresenter.class})
public void companyCreated(CompanyBean newBean);
}}}

By adding the presenter class, Mvp4g will be able to retrieve the instance of this class and add it to the list of handlers of the event.

You can also add an handler thanks to the presenter name by adding it to the attribute handlerNames of @Event annotation (not recommanded). In this case, you need to verify that a presenter with the given name exists.

If a presenter is added to an event, it must define the handler method associated to an event. By default, the name of this method is:  *"on" + the name of the event method*
and the parameters are the same as event method parameters.

In the following example:
{{{
@Event(handlers=CompanyListPresenter.class)
public void companyDeleted(CompanyBean newBean);

@Event(handlers=CompanyListPresenter.class)
public void companyCreated(CompanyBean newBean);
}}}

The presenter which class is CompanyListPresenter must define the following methods:
{{{
public void onCompanyDeleted(CompanyBean newBean){...}
public void onCompanyCreated(CompanyBean newBean){...}
}}}

You can change the handler method's name the presenter needs to define thanks to the attribute calledMethod of @Event annotation.

==Start View==

Each module needs to define a start view. The start view is the view that is added to the RootPanel or RootLayoutPanel when the application starts.

To define a start view, you need to specify the class of the start view thanks to the attribute startView of the @Events annotation that annotate your event bus interface. Mvp4g will automaticaly find the instance of the view. However Mvp4g will find the instance of the view only if the view is injected into a presenter.

In addition to set the class, you can also specify its name thanks to the attribute startViewName of the @Events annotation.

==Firing an event==

To throw an event, all you have to do is calling the event's method:
{{{
eventBus.companyCreated(new CompanyBean("company"));
}}}

You don't have to manage eventbus creation and implementation, the framework will do it for you. It will also inject it automaticaly to all your presenters.

==Logs==

Mvp4g implements a basic log system that let you see the events sent to the event bus. Each log will contain the class name of the module associated with the event bus, the name of the event and a string representation of the object associated with it if any. 

If you fire the following event:
{{{
eventBus.login("myUserName");
}}}

You will see the following log:
{{{
Module: Mvp4gModule || event: login || object: "myUserName"
}}}

Mvp4g uses the GWT.log method to display the log, which means that the log will appear in the hosted mode console. It also means that even if you activate the logs, it won't affect your compiled code since "calls [to GWT.log] are optimized out in web mode" (see GWT Reference API, http://google-web-toolkit.googlecode.com/svn/javadoc/2.0/index.html?overview-summary.html). 

To activate the log, you need to set to true the 'debug' attribute of the @Events annotation of your event bus interface.
{{{
@Events(..., debug=true)
public interface MainEventBus extends EventBusWithLookup {...}
}}}

==EventBus with lookup==

Similar to GWT internationalization system with Constants and ConstantsWithLookup, Mvp4g let you define an event bus with lookup, which means that you can fire an event thanks to its name. In order to so, an event bus with lookup has an extra method: dispatch.

Instead of:
{{{
eventBus.login("myUserName");
}}}
you can use:
{{{
eventBus.dispatch("login","myUserName");
}}}

Mvp4g will automaticaly find the right method to call on your event bus. However this functionality should be only when needed and with caution for two reasons:
 * Mvp4g can't verify at compile if the event with the given name exists. You will see the error only when you execute your code.
 * It is not type safe. If you decide to send an object which type is not the one associated to the event, Mvp4g won't detect it at compile time and an error will occur when you execute your code.

{{{
//let's say this call is correct
eventBus.dispatch("login","myUserName");

//call to an event that doesn't exist because of a typo error
eventBus.dispatch("lgin","myUserName");

//call with an object which type is incorrect
eventBus.dispatch("lgin",new User("myUserName"));
}}}

An event bus with lookup actually defines four different dispatch methods depending on if you want to associate