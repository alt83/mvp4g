#summary Comparaison between Mvp4g and GWTP (draft not completed yet)
#labels Deprecated

*THIS IS A DRAFT AND IS NOT COMPLETE YET*

=Mvp4g vs GWT-P (or gwt-platform)=

Mvp4g and GWTP are 2 frameworks implementing the best practices presented by Ray Ryan last year (MVP/Event bus/Dependency Injection). However their approach is a little bit different.

The idea behind Mvp4g is simple: whenever a presenter doesn't know how to do something, it asks the rest of the application to do it via an event. Thus a presenter will fire event to display its view, to ask other presenters to reveal themself...This means that you have to create a lot of events so it can work at only 2 conditions: creating events and managing them (ie set/control handlers) must be easy to do. And this is exactly what Mvp4g aims to do: all  you need to create and set handlers is one method and one annotation.

GWT-P has another approach. Their event bus is based on GWT Handler Manager so you need some code to create an event (one class and one handler). To solve this issue, they're going to implement mechanism to reduce the number of events needed. For example, you need only one event (provided by GWT-P) for a presenter to ask the rest of the application to display its view. You will also tend to use history token (via the place service) instead of events to ask other presenters to reveal themself.

Here is a comparaison of how the 2 frameworks deal with the main features needed for a GWT application based on MVP/Event bus.

==Events==

Even if GWT-P tries to reduce the number of events needed for an application, you will still need to create a certain number of them. As I said before, GWT-P is based on the GWT handler manager whereas Mvp4g introduces a new way to create events. 

This is how you would create an event and add an handler.

<table><tr align="center"><td>Mvp4g</td><td>GWTP</td></tr>
<tr valign="top"><td>
_EventBus: creating an event and registering an handler_
{{{
//this method is defined inside your event bus interface, 
//you need one interface for your whole application
@Event(handlers = OnePresenter.class)
void oneEvent(BeanOne one, BeanTwo two);
}}}

_Presenter: defining the handling method_
{{{
public class OnePresenter ... {

    public void onOneEvent(BeanOne one, BeanTwo two){
      //do sthg
    }

}
}}}

_Firing an event_
{{{
eventBus.oneEvent(beanOne, beanTwo);
}}}
</td><td>
_Creating an event (regular way with a GWT Handler Manager)_
{{{
public class OneEvent extends
    GwtEvent<OneEvent.OneHandler> {
  public interface OneHandler extends EventHandler {
    void onOneEvent(OneEvent event);
  }

  private static Type<OneHandler> TYPE = new Type<OneHandler>();
  
  private BeanOne one;
  private BeanTwo two;
  
  public OneEvent(BeanOne one, BeanTwo two){
    this.one = one;
    this.two = two;
  }
  
  @Override
  public Type<ShowMessageHandler> getAssociatedType() {
    return TYPE;
  }

  @Override
  protected void dispatch(OneHandler handler) {
    handler.onOneEvent(this);
  }    
  
} 
}}}
*OR* _Creating an event with the new tool provided by GWTP
(it generates the code above thanks to the following code)_
{{{
@GenEvent  
public class OneEvent {
 
  @Order(1) BeanOne one;       
  @Order(2) BeanTwo two;
   
}
}}}

_Presenter: registering the handler and defining the handling method_
{{{
public class OnePresenter ... implements OneHandler {

    public void onOneEvent(BeanOne one, BeanTwo two){
      //do sthg
    }
    
    public void onBind(){
        addRegisteredHandler( OneEvent.Type, this );
    }

} 
}}}
_firing an event_
{{{
eventBus.fire(new OneEvent(bean1, bean2));
}}}
</td></tr></table>

Even if GWTP has introduced a new mechanism to generate the boilerplate code needed by events, Mvp4g process is still simpler: *1 line of code & 1 annotation* to create an event and add x handlers againts *few annotations, a class and x lines of code for GWTP*.

I think another main advantage of Mvp4g compared to GWTP is that you can easily control your events and their flow. Indeed with the way Mvp4g implements events, you have all your events listed at one place and you can easily see the handlers of your event:
{{{
@Event(handlers = {PresenterOne.class, PresenterTwo.class})
void oneEvent(BeanOne one, BeanTwo two);
}}}   
For example, here, right away, you can see that oneEvent is handled by PresenterOne & PresenterTwo.

With GWTP (or any framework based on GWT HandlerManager), you have to go through several classes to retrieve this information.

Here is a list of other available features related to the event bus:
||Mvp4g|| GWTP||
||Event Filtering||Not available||
||Event Logs||Not available||
||Activation/deactivation of handlers||can be done but with more lines of codes||

==Creating a presenter==

<table><tr align="center"><td>*Mvp4g*</td><td>*GWTP*</td></tr>
<tr valign="top"><td>
_Presenter_
{{{
@Presenter(view=OneView)
public class OnePresenter extends LazyPresenter<OneEventBus, IOneView){...}
}}}
</td><td>
_Presenter_
{{{
public class OnePresenter extends PresenterImpl<IOneView, OnePresenter.MyProxy> {   
    @ProxyStandard     
    public interface MyProxy extends Proxy<MainPagePresenter> {} 
    ...
}
}}}
_GIN module_
{{{
bindPresenter(OnePresenter.class, IOneView.class, OneView.class, OnePresenter.MyProxy.class);         
}}}
_GIN injector_
{{{
Provider<OnePresenter> getOnePresenter(); 
}}}
</td></tr></table>
As you can see the process with Mvp4g is easier since you can create your presenter and inject the view thanks to one annotation. Mvp4g also uses GIN to generate the presenters/views but it hides its complexity and you will have to manipulate GIN classes only if you need extra configuration.

Mvp4g & GWTP both manages non-singleton presenters. 

GWT-P also offer a system to protect presenters in order them to be build only if you have the right to access it (with Mvp4g, you would use event filtering to prevent your handlers from being called).

==Nested Presenters (or how to display presenter's view inside other presenters' view)==

GWTP integrates a mechanism to do this thanks to one event provided by GWTP.

At the opposite, Mvp4g doesn't provide any specific mechanism and relies on events. However if we compare the 2 frameworks, the amount of code needed is pretty much the same.

<table><tr align="center"><td>*Mvp4g*</td><td>*GWTP*</td></tr>
<tr valign="top"><td>
_Event bus_
{{{
@Event(handlers = ParentPresenter.class)
void setView(Widget childView);
}}}
_Parent presenter_
{{{
public void onSetView(Widget childView){
  parentView.setView(childView);
}
}}}
_Parent view_
{{{
public void setView(Widget childView){
  //place view
}
}}}
</td><td>
_Parent Presenter_
{{{
public static final Type<RevealContentHandler<?>> TYPE_ChildView = new Type<RevealContentHandler<?>>();
}}}
_Parent View_
{{{
@Override 
public void setContent(Object slot, Widget content) { 
  if (slot == ParentPresenter.TYPE_ChildView) { 
     setChildView(content); 
  } else { 
     super.setContent(slot, content); 
  } 
}

public void setChildView(Widget content){
  ...
}
}}}
</td></tr></table>

GWTP also provides a particular type of nested presenter: Tabbed presenters.


==Place Service==

The ideas of Mvp4g & GWTP concerning the place service is also different: Mvp4g links a place to an event whereas GWTP links a place to a presenter. 

Linking a place to an event is more flexible because this way you can have a many-to-many relationship between tokens and presenters (since a token, transformed to an event, can be handled by several presenters and a presenter can handled several events). 

With the GWTP solution, you have a one-to-one relationship. With the one-to-one relationship, these problems can't be resolved directly :
 * for a particular token, you want two actions: for example, you want to display a presenter's view and select a menu.
 * you want a presenter to react to several tokens: for example, you have a menu bar that needs to display different menus according to the token.
I think you can find workaround for these issues. Also an issue has been accepted for GWTP to remove this limitationcreate many-to-many relationship (issue 78).

Also linking a place to an event is something that I found really powerful. Indeed thanks to this mechanism, you can fire events by url. It is really useful when you want another application to interact with your GWT project (for example, you can easily add a confirmation link inside an email).

They are 2 things I like about GWTP place service that I'd like to add to Mvp4g:
 * when you switch place (ie token), you can display a confirm message (usefull incase you're in a create page and you want user's confirmation to leave the page). Right now, you can only use the browser confirm, it would be nice to be able to use a customed one.
 * you can easily ask a presenter to reveal itselft by calling:
{{{
placeManager.revealPlace( new PlaceRequest("desiredNameToken") ); 
}}}      


Here is the code needed in case you want to create a place with one parameter: 

<table><tr align="center"><td>*Mvp4g*</td><td>*GWTP*</td></tr>
<tr valign="top"><td>
_History converter to convert the event to/from a token_
{{{
public class OneHistoryConverter ... {

  public String onOneEvent(String id){
      return "id=" + id;
  }
  
  public void convertFromToken( String eventType, String param, OneEventBus eventBus ){
      long id = Long.parse(param.split("=")[1]);
      eventBus.oneEvent(id);
  }
  
}
}}}
_Event bus: associating the history converter to the event_
{{{
@Event(..., historyConverter=OneHistoryConverter.class, historyName="oneHistoryEvent")
void oneEvent(long id);  
}}}

</td><td>
_Presenter: associating a token to the presenter, defining method to handle the tokens_
{{{
public class OnePresenter ... {

  private long id;
  
  @ProxyCodeSplit
  @NameToken("oneHistoryEvent")
  public interface MyProxy extends ProxyPlace<AboutUsPresenter> {...}
  
  @Override   
  public void prepareFromRequest(PlaceRequest placeRequest) {
       super.prepareFromRequest(placeRequest);      
       long id = placeRequest.getParameter("id", null);     
       getProxy().manualReveal(this);
  }    
        
  @Override   
  public PlaceRequest prepareRequest(PlaceRequest placeRequest) {     
        PlaceRequest result = new PlaceRequest(getProxy().getNameToken());
        result = result.with("id", id);
        return result;
  } 

}
}}}
</td></tr></table>

You basically have the same amount of code for both framework. However I think Mvp4g mechanism is easier to understand & cleaner since you don't mix in the same class your application logic and your token convertion process.


==Code splitting==
Both frameworks manage code splitting however their approach once again their approach is different:
 * Mvp4g forces you to divide your application into sub-modules. Each sub-module will have its own event bus and its own presenters/views. Sub-modules can communicate with each other thanks to events.
 * GWTP is more flexible and let you split any presenters or group of presenters. 

<table><tr align="center"><td>*Mvp4g*</td><td>*GWTP*</td></tr>
<tr valign="top"><td>
_Mvp4g Child Module_
{{{
public interface OneSubModule extends Mvp4gModule {...}
}}}
_Child Module Event bus_
{{{
@Events(..., module = OneSubModule.class)
public interface OneSubEventBus extends EventBus {

    //settings events to forward to parent if needed
    @Event(forwardToParent = true)
    public void oneParentEvent(...)

    @Event(forwardToParent = true)
    public void anotherParentEvent(...)

}
}}}
_Parent event bus: add child module_
{{{
@ChildModules( { @ChildModule(moduleClass = OneSubModule.class) })
@Events(...)
public interface RootEventBus ... { 

    //settings events to forward to child module
    @Event(modulesToLoad = {OneSubModule.class } )
    public void oneChildEvent(...)

    //settings events to forward to child module
    @Event(modulesToLoad = {OneSubModule.class } )
    public void anotherChildEvent(...)

}
}}}
</td><td>

_To split a single presenter_
{{{
public class OnePresenter ... {   

    @ProxyCodeSplit   
    public interface MyProxy extends ProxyPlace<HomePresenter>  {}
    ...
} 
}}}    

_To split a group of presenters_
{{{
public class OnePresenterBundle extends ProviderBundle {
      //one for each presenter
      public static final int ID_OnePresenter = 0;
      public static final int ID_AnotherPresenter = 1;    
      public static final int BUNDLE_SIZE = 2;        
      @Inject    
      TabbedPresenterBundle(final Provider<OnePresenter> onePresenter, final Provider<AnotherPresenter> anotherPresenter) {
            super(BUNDLE_SIZE);
            providers[ID_OnePresenter] = anotherPresenter;
            providers[ID_AnotherPresenter] = anotherPresenter;    
       }
}
}}}
{{{
//config needed for each presenter
public class OnePresenter ... {

    @ProxyCodeSplitBundle( bundleClass = OnePresenterBundle.class, id = OnePresenterBundle.ID_OnePresenter)
    public interface MyProxy extends Proxy<UserSettingsTabPresenter> { }
    ...
} 
}}}
</td></tr></table>

I have to admit code splitting is easier with GWTP and a lot more flexible. It is really easy to add or remove a presenter from a slice. The only thing I would say is that splitting a presenter by itself should be used with a lot of caution as you don't want to create slices that are too small.

One thing I like with Mvp4g Code splitting feature, is that it forces you to:
 * divide your application into sub-modules
 * set the communication between each sub-modules via events

This way you end up with a project divided in smaller pieces that are pretty independant from each other. You can then have different developers to work on them.

==Optimization==

Both frameworks implement a pattern to build presenters only when they need to handle their first event, thanks to lazy loading for Mvp4g or proxies for GWTP. This way, you can have fast application.

==Server Communication==

Mvp4g doesn't integrate any library to communicate with the server, it let you choose the one you want. Mvp4g can be used with gwt-dispatch for example.

GWTP integrates and improves gwt-dispatch (http://code.google.com/p/gwt-platform/wiki/ComparisonWithGwtDispatch). You can still use another library if you want to.


==Conclusion==

I haven't gone over all the features offered by Mvp4g or GWTP but I hope it gives you a better idea of the 2 frameworks.

I think GWTP is a good framework that allows you to build efficient applications. However I still prefer Mvp4g because you can also build fast and efficient application with Mvp4g but it's simpler (so you need less code) and it's more flexible (since everything relies on events).

The main advantage of Mvp4g over GWTP is definetely the way you can define your event bus: it's easy, fast and so convenient to maintain. The event bus is the heart of your application so it's important for it to be well done.

Now my opinion may not be fair (since I'm the creator of Mvp4g) so I'd like to hear yours...